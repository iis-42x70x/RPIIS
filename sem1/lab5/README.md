# Лабораторная работа №5

## Цель работы:
-  Освоить командные оболочки *shell* (для OS семейства Unix) и *cmd* (для OS семейства MS Windows):
    - изучить основные встроенные команды,
    - научиться писать файлы сценариев,
    - научиться соотносить командные оболочки для разных OS.
-  Освоить командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.

## Задача:
-  Познакомиться с консольными программными окружениями OS Windows и OS Linux.
-  Получить практические навыки работы в консоли, использования консольных команд.
-  Выполнить выданный преподавателем вариант задания.

## Указания к выполнению:
Для получения помощи используйте
1. `help` в cmd.exe
2. `help` , `man`, `info` в Linux и `<имя команды> ­­help`.

## Мой вариант:
### **74** Создать файл sh и bat, который выполняет следующее: 
На вход пакетному файлу приходит абсолютный путь к папке и формат файла (например, doc) (как параметры пакетного файла). В папке найти все файлы указанного формата, вывести в консоль их количество. Если число четное, то вывести в консоль сообщение о количестве активных процессов в ОС в формате “Число активных процессов - Х”. Если число нечетное - завершить выполнение программы через 7 секунд.

## Выполнение работы:
Файл **.sh** начинается с shebang (это строка в начале скрипта). Она указывает какой интерпретатор использовать для выполнения скрипта. В моем случае это выглядит так:

```bash
#!/bin/bash
```

Что указывает на использование *Bash*.

Скрипт **.bat** начинается с команды `@echo off`. Она используется для того, чтобы скрипт не выводил в консоль каждую выполняемую команду, и делает вывод чище и читабельнее.

### Получение параметров пакетного файла

В скрипте на **Bash** передача параметров происходит так:

```bash
# Проверяем, что юзер передал оба параметра
if [ -z "$1" ]; then
    echo "Ошибка: Не указан путь к папке."
    exit 1
fi

if [ -z "$2" ]; then
    echo "Ошибка: Не указан формат файла."
    exit 1
fi

# Сохраняем параметры
folder_path="$1"
file_format="$2"
```

Вначале проходит проверка, передал ли пользователь все параметры, необходимые для выполнения программы. Здесь `[ -z "$1" ]` это условие, в котором опция `-z` возвращает **true**, если первый параметр пакетного файла `$1` является пустым. При истинности условия с помощью `echo` выводим в консоль соответствующее сообщение об ошибке и выполняем команду `exit 1` для взавершения работы скрипта ( указываем `1` т.к. это код завершения скрипта, означающий, что работа прервана из-за ошибки). Аналогичную операцию проводим со вторым параметром файла. Далее сохраняем введенные параметры. В `folder_path` сохраняем путь к папке (1-ый параметр), в `file_format` сохраняем формат файла для поиска (2-й параметр).

В скрипте на **Batch** аналогичные действия выглядят так:

```batch
REM вводим путь к папке и формат файла
set folder_path=%1
set file_format=%2
if "%folder_path%"=="" (
    echo Ошибка: пустой путь!
)
if "%file_format%"=="" (
    echo Ошибка: пустой формат!
)
```

С помощью `set folder_path=%1` сохраняем путь к папке (1-ый параметр) в переменную `folder_path` , аналогично в `file_format` сохраняем формат файла для поиска (2-й параметр). Далее проверяем, передал ли пользователь все параметры, необходимые для выполнения программы.

Далее программа находит количество файлов заданного формата в заданной папке. В скрипте на **Bash** это выглядит так:

```Bash
file_count=$(find "$folder_path" -type f -name "*.$file_format" | wc -l)
echo "Количество файлов с форматом .$file_format в папке $folder_path: $file_count"
```

Команде для поиска файлов и каталогов `find` поступает значение переменной `folder_path` как путь к каталогу для поиска файлов. Опция `-type` с параметром `f` указывает команде `find` то, что необходимо искать только файлы , а не каталоги по заданному фильтру. Фильтр для поиска файлов - `-name "*.$file_format"` указывает на поиск файлов, у которых в качестве имени любая последовательность символов, а в качестве расширения - введённый пользователем 2-й параметр пакетного файла. Далее символ `|` передает результат команды `find` команде `wc -l` , которая считает количество строк в выводе `find`. Флаг `-l` в команде `wc` используем для подсчёта количества строк в переданном результате предыдущей команды.

В скрипте на **Batch** аналогичные действия выглядят так:

```Batch
set count=0
for /f %%a in ('dir "%folder_path%\"*.%file_format%"" /b /a-d ^| find /C /V ""') do (
    set count=%%a
) 
echo Количество файлов формата %file_format% - %count%
```

Описываем переменную `count` с начальным значением 0. Запускаем цикл, он будет обрабатывать строки вывода команды после `in`, количество файлов хранится в переменной `a`. Команда `dir` выводит содержимое папки по шаблону `"%folder_path%\"*.%file_format%""` , опция `/b` нужна, чтобы выводить только имена файлов без лишних данных, опция `/a-d` исключает каталоги (выводит только файлы). Символ `^|` передаёт результат команды `dir` в `find`. `find` — команда поиска строк, опция `/C` считает количество строк в выводе, `/V ""`— ищет строки, которые не совпадают с пустой строкой (по сути, считает все строки). `do ( set count=%%a ):` выполняется для каждой строки вывода команды `find` и обновляет кол-во найденных файлов в `count`.
