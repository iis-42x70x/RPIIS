# Лабораторная работа №5

## Цель работы:
-  Освоить командные оболочки *shell* (для OS семейства Unix) и *cmd* (для OS семейства MS Windows):
    - изучить основные встроенные команды,
    - научиться писать файлы сценариев,
    - научиться соотносить командные оболочки для разных OS.
-  Освоить командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.

## Задача:
-  Познакомиться с консольными программными окружениями OS Windows и OS Linux.
-  Получить практические навыки работы в консоли, использования консольных команд.
-  Выполнить выданный преподавателем вариант задания.

## Указания к выполнению:
Для получения помощи используйте
1. `help` в cmd.exe
2. `help` , `man`, `info` в Linux и `<имя команды> ­­help`.

## Мой вариант:
### **74** Создать файл sh и bat, который выполняет следующее: 
На вход пакетному файлу приходит абсолютный путь к папке и формат файла (например, doc) (как параметры пакетного файла). В папке найти все файлы указанного формата, вывести в консоль их количество. Если число четное, то вывести в консоль сообщение о количестве активных процессов в ОС в формате “Число активных процессов - Х”. Если число нечетное - завершить выполнение программы через 7 секунд.

## Выполнение работы:
Файл **.sh** начинается с shebang (это строка в начале скрипта). Она указывает какой интерпретатор использовать для выполнения скрипта. В моем случае это выглядит так:

```bash
#!/bin/bash
```

Что указывает на использование *Bash*.

Скрипт **.bat** начинается с команды `@echo off`. Она используется для того, чтобы скрипт не выводил в консоль каждую выполняемую команду, и делает вывод чище и читабельнее.

### Получение параметров пакетного файла

В скрипте на **Bash** передача параметров происходит так:

```bash
# Проверяем, что юзер передал оба параметра
if [ -z "$1" ]; then
    echo "Ошибка: Не указан путь к папке."
    exit 1
fi

if [ -z "$2" ]; then
    echo "Ошибка: Не указан формат файла."
    exit 1
fi

# Сохраняем параметры
folder_path="$1"
file_format="$2"
```

Вначале проходит проверка, передал ли пользователь все параметры, необходимые для выполнения программы. Здесь `[ -z "$1" ]` это условие, в котором опция `-z` возвращает **true**, если первый параметр пакетного файла `$1` является пустым. При истинности условия с помощью `echo` выводим в консоль соответствующее сообщение об ошибке и выполняем команду `exit 1` для взавершения работы скрипта ( указываем `1` т.к. это код завершения скрипта, означающий, что работа прервана из-за ошибки). Аналогичную операцию проводим со вторым параметром файла. Далее сохраняем введенные параметры. В `folder_path` сохраняем путь к папке (1-ый параметр), в `file_format` сохраняем формат файла для поиска (2-й параметр).

В скрипте на **Batch** аналогичные действия выглядят так:

```batch
REM вводим путь к папке и формат файла
set folder_path=%1
set file_format=%2
if "%folder_path%"=="" (
    echo Ошибка: пустой путь!
)
if "%file_format%"=="" (
    echo Ошибка: пустой формат!
)
```

С помощью `set folder_path=%1` сохраняем путь к папке (1-ый параметр) в переменную `folder_path` , аналогично в `file_format` сохраняем формат файла для поиска (2-й параметр). Далее проверяем, передал ли пользователь все параметры, необходимые для выполнения программы.

Далее программа находит количество файлов заданного формата в заданной папке. В скрипте на **Bash** это выглядит так:

```Bash
file_count=$(find "$folder_path" -type f -name "*.$file_format" | wc -l)
echo "Количество файлов с форматом .$file_format в папке $folder_path: $file_count"
```

Команде для поиска файлов и каталогов `find` поступает значение переменной `folder_path` как путь к каталогу для поиска файлов. Опция `-type` с параметром `f` указывает команде `find` то, что необходимо искать только файлы , а не каталоги по заданному фильтру. Фильтр для поиска файлов - `-name "*.$file_format"` указывает на поиск файлов, у которых в качестве имени любая последовательность символов, а в качестве расширения - введённый пользователем 2-й параметр пакетного файла. Далее символ `|` передает результат команды `find` команде `wc -l` , которая считает количество строк в выводе `find`. Флаг `-l` в команде `wc` используем для подсчёта количества строк в переданном результате предыдущей команды.

В скрипте на **Batch** аналогичные действия выглядят так:

```Batch
set count=0
for /f %%a in ('dir "%folder_path%\"*.%file_format%"" /b /a-d ^| find /C /V ""') do (
    set count=%%a
) 
echo Количество файлов формата %file_format% - %count%
```

Описываем переменную `count` с начальным значением 0. Запускаем цикл, он будет обрабатывать строки вывода команды после `in`, которые хранятся в переменной `%%a` (цикл выполняется столько раз, сколько строк в выводе команды). Команда `dir` выводит содержимое папки по шаблону `"%folder_path%\"*.%file_format%""` , опция `/b` нужна, чтобы выводить только имена файлов без лишних данных, опция `/a-d` исключает каталоги (выводит только файлы). Символ `^|` передаёт результат команды `dir` в `find`. `find` — команда поиска строк, опция `/C` считает количество строк в выводе, `/V ""`— ищет строки, которые не совпадают с пустой строкой (по сути, считает все строки). `do ( set count=%%a ):` выполняется для каждой строки вывода команды `find` и обновляет кол-во найденных файлов в `count`. 

Далее проверяем, четное ли количество нужных файлов. В скрипте на **Bash** это выглядит так:

```Bash
if (($file_count % 2 == 0 )); then # число нужных файлов четное
    number_of_processes=$(ps -e --no-headers | wc -l) # число процессов
    echo "Число активных процессов - $number_of_processes"
else # число нужных файлов нечетное
    for (( i=7; i>=1; i-- ))
    do
        echo "Завершение программы через $i"
        sleep 1
    done
    echo "Программа завершена."
fi
```

### Если число нужных файлов четное:

В переменную `number_of_processes` заносим число активных процессов в ОС с помощью команды `ps -e --no-headers`. Опция `-e` позволяет вывести абослютно все процессы, опция `--no-headers` убирает заголовок таблицы, чтобы в выводе остались только строки с процессами и программа получила точное значение. Символ `|` передает результат команды `ps` команде `wc -l` , которая считает количество строк в выводе `ps`. Флаг `-l` в команде `wc` используем для подсчёта количества строк в переданном результате предыдущей команды.

### Если число нужных файлов нечетное:

Начинается цикл, с помощью которого программа завершит работу ровно через 7 секунд. Каждую секунду выводится сообщение о кол-ве секунд до завершения работы и выполняется команда `sleep 1`, с помощью которой программа приостанавливается на 1 с.

На **Batch** проверка выглялит так:

```Batch
set /a ost=%count% %% 2 
if %ost%==0 (
    rem Получаем список процессов и считаем количество строк
    for /f "tokens=*" %%A in ('tasklist ^| find /C /V ""') do set Processes=%%A 
    echo Число активных процессов - %Processes%  
) else (
    rem Цикл отсчета времени
    for /l %%i in (7,-1,1) do (
        echo До завершения программы %%i секунд
        timeout /t 1 >nul
    )
    echo Программа завершена.
)
```

В переменную `ost` заносим остаток от деления кол-ва файлов с нужным расширением в заданной папке. Опция `/a` позволяет выполнять математические вычисления. 

### Если число нужных файлов чётное:

Запускаем цикл, он будет построчно обрабатывать строки вывода команды после `in`, которые хранятся в переменной `%%A`. `tokens=*` это параметр цикла, который указывает на то, какие части строки извлечь из текущей строки, в данном случае необходимо извлечь полную строку. Команда `tasklist` выводит список всех активных процессов в системе. Символ `^|` передаёт результат команды `tasklist` в `find`. `find` — команда поиска строк, опция `/C` считает количество строк в выводе, `/V ""`— ищет строки, которые не совпадают с пустой строкой (по сути, считает все строки). `do set Processes=%%A ` выполняется для каждой строки вывода команды `find` и обновляет кол-во процессов в `Processes`. 

### Если число нужных файлов нечетное:

Запукаем цикл отсчета времени до завершения программы.`%%i` — переменная цикла. 7 — начальное значение переменной, -1 — шаг уменьшения переменной, 1 — конечное значение переменной. Команда `timeout /t 1` приостанавливает выполнение программы на 1 секунду. `>nul` нужно для того, чтобы на экране не отображалось сообщение об ожидании.

## Инструкция к запуску программы

## Запуск скрипта на **Bash**(Linux)

Запускается файл через терминал. Сначала нужно дать файлу право на выполнение, это делается так:

```Bash
chmod +x script.sh
```

Чтобы запустить файл в терминале вводим `./имя_файла.sh` или `путь/к_файлу/имя_файла.sh`. В нашем случае нужно передать параметры пакетного файла, поэтому вводим в терминал `./имя_файла.sh путь_к_папке расширение_файла` или `путь/к_файлу/имя_файла.sh путь_к_папке расширение_файла`.

## Запуск скрипта на **Batch**(Windows)

Файл запускается через командную строку. Чтобы запустить скрипт переходим в папку со скриптом и пишем `script_name.bat путь_к_папке расширение_файла`.

### Вывод

В процессе выполнения работы я:
-    Освоил командные оболочки shell (для OS семейства Unix) и cmd (для OS семейства MS Windows)
-    Освоил командное окружение для OS семейства Unix(утилиты из пакета GNU Core Utilities), и соответствующие им утилиты для OS семейства MS Windows.
-    Создал скрипты на **Bash** и **Batch**, которые выполняют мой вариант задания.
